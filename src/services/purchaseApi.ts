import { supabase } from '@/integrations/supabase/client';
import type {
  PurchaseRequest,
  PurchaseRequestItem,
  CreatePurchaseRequestPayload,
  CreatePurchaseRequestItemPayload,
} from '@/types/purchase';

// Note: The purchase_* tables are not in the auto-generated Supabase types yet.
// We use type assertions to work with these new tables.

// Get all purchase requests ordered by creation date
export async function getPurchaseRequests(): Promise<PurchaseRequest[]> {
  const { data, error } = await (supabase as any)
    .from('purchase_requests')
    .select('*')
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching purchase requests:', error);
    throw error;
  }

  return (data || []) as PurchaseRequest[];
}

// Get a single purchase request by ID
export async function getPurchaseRequestById(id: string): Promise<PurchaseRequest | null> {
  const { data, error } = await (supabase as any)
    .from('purchase_requests')
    .select('*')
    .eq('id', id)
    .maybeSingle();

  if (error) {
    console.error('Error fetching purchase request:', error);
    throw error;
  }

  return data as PurchaseRequest | null;
}

// Get items for a purchase request
export async function getPurchaseRequestItems(requestId: string): Promise<PurchaseRequestItem[]> {
  const { data, error } = await (supabase as any)
    .from('purchase_request_items')
    .select('*')
    .eq('request_id', requestId)
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching purchase request items:', error);
    throw error;
  }

  return (data || []) as PurchaseRequestItem[];
}

// Create a new purchase request (number is auto-generated by DB default)
export async function createPurchaseRequest(
  payload: CreatePurchaseRequestPayload
): Promise<PurchaseRequest> {
  const { data, error } = await (supabase as any)
    .from('purchase_requests')
    .insert({
      purchase_type: payload.purchase_type,
      description: payload.description || null,
      desired_date: payload.desired_date || null,
      created_by: payload.created_by,
      status: 'DRAFT',
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating purchase request:', error);
    throw error;
  }

  return data as PurchaseRequest;
}

// Update purchase request status
export async function updatePurchaseRequestStatus(
  id: string,
  status: string
): Promise<void> {
  const { error } = await (supabase as any)
    .from('purchase_requests')
    .update({ status })
    .eq('id', id);

  if (error) {
    console.error('Error updating purchase request status:', error);
    throw error;
  }
}

// Create items for a purchase request
export async function createPurchaseRequestItems(
  items: CreatePurchaseRequestItemPayload[]
): Promise<PurchaseRequestItem[]> {
  if (items.length === 0) return [];

  const { data, error } = await (supabase as any)
    .from('purchase_request_items')
    .insert(items.map(item => ({
      request_id: item.request_id,
      name: item.name,
      unit: item.unit,
      quantity: item.quantity,
      status: 'IN_PROGRESS',
    })))
    .select();

  if (error) {
    console.error('Error creating purchase request items:', error);
    throw error;
  }

  return (data || []) as PurchaseRequestItem[];
}

// Delete a purchase request (only drafts)
export async function deletePurchaseRequest(id: string): Promise<void> {
  const { error } = await (supabase as any)
    .from('purchase_requests')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('Error deleting purchase request:', error);
    throw error;
  }
}

// Sync request status based on invoice status changes
// This function updates the purchase request status to reflect the overall progress
export async function syncRequestStatusFromInvoice(
  requestId: string,
  newInvoiceStatus: string
): Promise<void> {
  // Determine the new request status based on invoice status
  let newRequestStatus: string | null = null;

  switch (newInvoiceStatus) {
    case 'PENDING_COO':
    case 'PENDING_CEO':
      newRequestStatus = 'INVOICE_PENDING';
      break;
    case 'TO_PAY':
    case 'DELIVERED':
      newRequestStatus = 'DELIVERING';
      break;
    case 'PAID':
      newRequestStatus = 'COMPLETED';
      break;
    default:
      // For DRAFT or REJECTED, don't change request status
      return;
  }

  if (newRequestStatus) {
    // Check current request status - only update if it makes sense
    const { data: request, error: fetchError } = await (supabase as any)
      .from('purchase_requests')
      .select('status')
      .eq('id', requestId)
      .single();

    if (fetchError || !request) {
      console.error('Error fetching request for status sync:', fetchError);
      return;
    }

    // Define status priority (higher = more progress)
    const statusPriority: Record<string, number> = {
      'DRAFT': 0,
      'PENDING_APPROVAL': 1,
      'IN_PROGRESS': 2,
      'INVOICE_PENDING': 3,
      'DELIVERING': 4,
      'COMPLETED': 5,
      'REJECTED': -1,
    };

    const currentPriority = statusPriority[request.status] ?? 0;
    const newPriority = statusPriority[newRequestStatus] ?? 0;

    // Only update if the new status represents more progress
    if (newPriority > currentPriority) {
      const { error } = await (supabase as any)
        .from('purchase_requests')
        .update({ status: newRequestStatus })
        .eq('id', requestId);

      if (error) {
        console.error('Error syncing request status:', error);
      }
    }
  }
}
